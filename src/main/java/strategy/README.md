## Strategy Pattern



> **상속**

- **공통된 코드를 추상화하여 재사용성을 높이고 중복을 줄인다.**
- 새로운 요구사항이 생긴다면? 슈퍼클래스와 서브클래스가 이미 존재한다고 가정하자.
  - 새로운 슈퍼클래스에 해당 기능을 구현하는 방법을 생각해볼 수 있다.
    - **서브클래스 중에 해당 기능이 필요없는 클래스가 있을 수 있다.** (super:Duck, sub:RubberDuck 에 날다라는 기능을 추가하는 경우 )
    - 오버라이딩 해서 동작하지 않도록 하는 방법이 있을 수 있으나 이런 서브클래스들이 더 추가된다면 같은 코드(동작하지 않도록 하는)가 **중복**될 수 있다.
  - 인터페이스로 새로운 기능을 추가한다
    - 인터페이스로 새로운 기능을 추가하고 그 기능을 구현해야하는 클래스만 구현하도록 해서 위 문제를 해결 할 수 있으나 **코드의 재사용성을 기대 할 수 없다**.

<br>
<br>

>  **소프트웨어 개발에 있어 변화는 항상 존재한다**

- **달라지는 부분을 찾아내고 달라지지 않는 부분으로부터 분리하자**
  - **바뀌는 부분은 따로 뽑아서 캡슐화시킨다.** 그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치거나 확장할 수 있다

<br>
<br>

- **구현이 아닌 상위형식에 맞춰서 프로그래밍한다**

  - 상위 형식인 추상클래스나 인터페이스를 기준으로 구현하게 되면 어떤 객체든 서브클래스라면 할당할 수 있어 유연해진다.

  - ```java
    // 상위 형식에 맞춰 프로그래밍한다
    Animal animal = new Dog();
    animal.makeSound();
    
    // 런타임에 동적 할당한다
    Aninal animal = getAnimal(); // 어떤 동물이 들어갈 지 컴파일 시점에 알 수 없다.
    animal.makeSound();
    
    ```

<br>
<br>

- **동적으로 메서드를 구현하자**
  
  - **Strategy Pattern의 핵심**
  
  <img src="https://github.com/jayyhkwon/DesignPattern/blob/master/src/main/java/strategy/StrategyPattern.png"/>

<br>
<br>

- **상속보다 합성이 나을 수 있다**
  - 합성을 이용하여 클래스를 설계하면 유연성을 크게 향상 시킬 수 있다
  - 단순히 알고리즘군을 별도의 클래스의 집합으로 캡슐화할 수 있도록 만들어 주는 것 뿐만 아니라 구성요소로 사용하는 객체에서 올바른 행동 인터페이스를 구현하기만 하면 실행시에 행동을 바꿀 수 있게 해준다
  - 합성은 여러 디자인 패턴에서 쓰이며, 앞으로 이 책 전반에 걸쳐서 그 장단점을 배울 수 있을 것이다



- **규모가 크지 않은데 스트레티지 패턴을 사용하면 클래스나 인터페이스의 수가 늘어나서 애플리케이션이 복잡해질 수 있다.**
  **이런 경우 default 메서드나 슈퍼클래스로 구현하는 것도 방법이 될 수 있지 않을까?**



<img src="https://github.com/jayyhkwon/DesignPattern/blob/master/src/main/java/strategy/DefaultMethod.png"/>








